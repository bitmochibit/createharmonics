<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AUDIO_SYSTEM.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AUDIO_SYSTEM.md" />
              <option name="updatedContent" value="# Audio Provider System&#10;&#10;This system provides automatic downloading and management of audio tools (ffmpeg and yt-dlp) for the CreateHarmonics mod.&#10;&#10;## Architecture&#10;&#10;### Core Components&#10;&#10;1. **AudioProvider Interface** (`audio/provider/AudioProvider.kt`)&#10;   - Defines the contract for all audio providers&#10;   - Methods: `isAvailable()`, `install()`, `getExecutablePath()`, `getName()`&#10;&#10;2. **AbstractDownloadableProvider** (`audio/provider/AbstractDownloadableProvider.kt`)&#10;   - Base implementation for downloadable audio tools&#10;   - Handles download, extraction, and executable discovery&#10;   - Platform-specific executable location&#10;   - Supports both direct downloads and zip archives&#10;&#10;3. **FFMPEG Provider** (`audio/provider/FFMPEG.kt`)&#10;   - Downloads ffmpeg based on OS and architecture&#10;   - Windows: gyan.dev builds&#10;   - macOS: evermeet.cx builds&#10;   - Linux: johnvansickle static builds&#10;&#10;4. **YTDL Provider** (`audio/provider/YTDL.kt`)&#10;   - Downloads yt-dlp from GitHub releases&#10;   - Platform-specific binaries for Windows, macOS, and Linux&#10;   - Supports ARM64 and x86_64 architectures&#10;&#10;5. **AudioProviderManager** (`audio/provider/AudioProviderManager.kt`)&#10;   - Central registry for all audio providers&#10;   - Manages provider installation and availability&#10;   - Provides status information&#10;&#10;6. **AudioDownloader** (`audio/AudioDownloader.kt`)&#10;   - High-level API for downloading and converting audio&#10;   - Uses yt-dlp for downloading from URLs&#10;   - Uses ffmpeg for audio conversion&#10;   - Automatically ensures providers are available&#10;&#10;## Usage&#10;&#10;### Basic Audio Download&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.AudioDownloader&#10;import java.io.File&#10;&#10;// Download and convert audio to OGG format&#10;val success = AudioDownloader.downloadAndConvert(&#10;    url = &quot;https://www.youtube.com/watch?v=example&quot;,&#10;    outputFile = File(&quot;audio/output.ogg&quot;),&#10;    format = &quot;ogg&quot;&#10;)&#10;&#10;if (success) {&#10;    println(&quot;Audio downloaded successfully!&quot;)&#10;}&#10;```&#10;&#10;### Check Provider Status&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.provider.AudioProviderManager&#10;&#10;// Check if all providers are ready&#10;val allReady = AudioProviderManager.areAllProvidersAvailable()&#10;&#10;// Get status for each provider&#10;val status = AudioProviderManager.getProviderStatus()&#10;status.forEach { (name, available) -&gt;&#10;    println(&quot;$name: ${if (available) &quot;Available&quot; else &quot;Not Available&quot;}&quot;)&#10;}&#10;```&#10;&#10;### Manual Provider Installation&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.provider.FFMPEG&#10;import me.mochibit.createharmonics.audio.provider.YTDL&#10;&#10;// Install individual providers&#10;if (!FFMPEG.isAvailable()) {&#10;    FFMPEG.install()&#10;}&#10;&#10;if (!YTDL.isAvailable()) {&#10;    YTDL.install()&#10;}&#10;&#10;// Or install all missing providers&#10;AudioProviderManager.installMissingProviders()&#10;```&#10;&#10;### Creating Custom Music Discs&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.content.item.EtherealDiscItem&#10;import kotlin.time.Duration.Companion.minutes&#10;&#10;val customDisc = EtherealDiscItem(&#10;    comparatorOutput = 15,&#10;    soundEvent = { ModSounds.CUSTOM_DISC_SOUND.get() },&#10;    duration = 5.minutes&#10;)&#10;```&#10;&#10;## Directory Structure&#10;&#10;Audio providers are installed to:&#10;```&#10;audio_providers/&#10;├── ffmpeg/&#10;│   └── ffmpeg.exe (or ffmpeg on Unix)&#10;└── yt-dlp/&#10;    └── yt-dlp.exe (or yt-dlp on Unix)&#10;```&#10;&#10;## Supported Platforms&#10;&#10;- **Windows**: x86_64&#10;- **macOS**: x86_64 and ARM64 (Apple Silicon)&#10;- **Linux**: x86_64 and ARM64&#10;&#10;## Features&#10;&#10;- ✅ Automatic provider installation&#10;- ✅ Platform detection and appropriate binary selection&#10;- ✅ Recursive executable discovery in extracted archives&#10;- ✅ Executable permission management&#10;- ✅ Caching of executable paths&#10;- ✅ Error handling and logging&#10;- ✅ Support for multiple audio formats (ogg, mp3, wav, etc.)&#10;&#10;## Extension Points&#10;&#10;### Adding a New Provider&#10;&#10;1. Create a new object extending `AbstractDownloadableProvider`:&#10;&#10;```kotlin&#10;object NewProvider: AbstractDownloadableProvider(&#10;    &quot;provider-name&quot;,&#10;    File(&quot;audio_providers/provider-name&quot;),&#10;    &quot;download-file.zip&quot;,&#10;    &quot;provider-repo&quot;&#10;) {&#10;    override fun getDownloadUrl(): String {&#10;        val osName = System.getProperty(&quot;os.name&quot;).lowercase()&#10;        return when {&#10;            osName.contains(&quot;win&quot;) -&gt; &quot;https://example.com/windows-build.zip&quot;&#10;            osName.contains(&quot;mac&quot;) -&gt; &quot;https://example.com/macos-build.zip&quot;&#10;            osName.contains(&quot;linux&quot;) -&gt; &quot;https://example.com/linux-build.tar.gz&quot;&#10;            else -&gt; throw UnsupportedOperationException(&quot;Unsupported OS: $osName&quot;)&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;2. Register it in `AudioProviderManager`:&#10;&#10;```kotlin&#10;init {&#10;    registerProvider(FFMPEG)&#10;    registerProvider(YTDL)&#10;    registerProvider(NewProvider) // Add your provider&#10;}&#10;```&#10;&#10;## Notes&#10;&#10;- The system automatically handles zip extraction&#10;- Executables are made executable on Unix systems&#10;- Providers are only downloaded once (cached)&#10;- All operations are logged through the mod's logger&#10;- Thread-safe provider management&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/CreateJukeboxAudioPlayer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/CreateJukeboxAudioPlayer.kt" />
              <option name="updatedContent" value="package me.mochibit.createharmonics.audio&#10;&#10;import me.mochibit.createharmonics.Logger.err&#10;import me.mochibit.createharmonics.Logger.info&#10;import net.minecraft.client.Minecraft&#10;import net.minecraft.sounds.SoundSource&#10;import java.util.*&#10;import kotlin.math.*&#10;&#10;/**&#10; * RPM-based audio player for Create-style jukeboxes&#10; * Handles pitch changes based on rotational speed&#10; */&#10;class CreateJukeboxAudioPlayer {&#10;    &#10;    companion object {&#10;        private val activeJukeboxes = mutableMapOf&lt;UUID, JukeboxPlayback&gt;()&#10;        private const val STANDARD_RPM = 33.33f // Standard vinyl RPM for 1.0 pitch&#10;        private const val MAX_PITCH_CHANGE = 4.0f // Maximum pitch multiplier&#10;        private const val MIN_PITCH_CHANGE = 0.25f // Minimum pitch multiplier&#10;    }&#10;    &#10;    data class JukeboxPlayback(&#10;        val discId: UUID,&#10;        val audioPlayer: SimpleYouTubeAudioPlayer,&#10;        var currentRpm: Float,&#10;        var isPlaying: Boolean,&#10;        val x: Double,&#10;        val y: Double,&#10;        val z: Double&#10;    )&#10;    &#10;    /**&#10;     * Starts playing a disc in a jukebox at given RPM&#10;     */&#10;    fun playDisc(&#10;        jukeboxId: UUID,&#10;        discId: UUID,&#10;        rpm: Float,&#10;        x: Double,&#10;        y: Double,&#10;        z: Double,&#10;        volume: Float = 1.0f&#10;    ): Boolean {&#10;        try {&#10;            // Stop any existing playback for this jukebox&#10;            stopJukebox(jukeboxId)&#10;            &#10;            // Get disc data&#10;            val discData = AudioDiscRegistry.getDiscData(discId) ?: run {&#10;                err(&quot;Disc not found: $discId&quot;)&#10;                return false&#10;            }&#10;            &#10;            info(&quot;Starting jukebox playback: ${discData.title} at ${rpm} RPM&quot;)&#10;            &#10;            // Calculate pitch based on RPM&#10;            val pitch = calculatePitchFromRpm(rpm)&#10;            &#10;            // Create new audio player for this jukebox&#10;            val audioPlayer = SimpleYouTubeAudioPlayer()&#10;            &#10;            // Start playback&#10;            val playbackFuture = audioPlayer.playYouTubeAudioDirect(&#10;                discData.youtubeUrl, &#10;                volume&#10;            )&#10;            &#10;            // Store jukebox state&#10;            val playback = JukeboxPlayback(&#10;                discId = discId,&#10;                audioPlayer = audioPlayer,&#10;                currentRpm = rpm,&#10;                isPlaying = true,&#10;                x = x,&#10;                y = y,&#10;                z = z&#10;            )&#10;            &#10;            activeJukeboxes[jukeboxId] = playback&#10;            &#10;            // Handle playback result&#10;            playbackFuture.thenAccept { success -&gt;&#10;                if (!success) {&#10;                    err(&quot;Failed to start audio playback for jukebox: $jukeboxId&quot;)&#10;                    activeJukeboxes.remove(jukeboxId)&#10;                } else {&#10;                    info(&quot;Successfully started jukebox audio at pitch: $pitch&quot;)&#10;                }&#10;            }&#10;            &#10;            return true&#10;            &#10;        } catch (e: Exception) {&#10;            err(&quot;Error playing disc in jukebox: ${e.message}&quot;)&#10;            return false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Updates RPM for a playing jukebox (changes pitch in real-time)&#10;     */&#10;    fun updateRpm(jukeboxId: UUID, newRpm: Float) {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return&#10;        &#10;        if (!playback.isPlaying) return&#10;        &#10;        val oldPitch = calculatePitchFromRpm(playback.currentRpm)&#10;        val newPitch = calculatePitchFromRpm(newRpm)&#10;        &#10;        playback.currentRpm = newRpm&#10;        &#10;        info(&quot;Updated jukebox RPM: ${playback.currentRpm} -&gt; $newRpm (pitch: $oldPitch -&gt; $newPitch)&quot;)&#10;        &#10;        // For real-time pitch changes, we'd need to restart with new pitch&#10;        // Java's audio system doesn't support real-time pitch shifting easily&#10;        // This is a limitation we'll note for future enhancement&#10;        &#10;        // TODO: Implement real-time pitch shifting or restart playback with new pitch&#10;        // For now, we just update the stored RPM value&#10;    }&#10;    &#10;    /**&#10;     * Stops a jukebox playback&#10;     */&#10;    fun stopJukebox(jukeboxId: UUID) {&#10;        val playback = activeJukeboxes.remove(jukeboxId) ?: return&#10;        &#10;        playback.audioPlayer.stopCurrentAudio()&#10;        playback.isPlaying = false&#10;        &#10;        info(&quot;Stopped jukebox: $jukeboxId&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Pauses/resumes jukebox (when RPM drops to 0)&#10;     */&#10;    fun setJukeboxPaused(jukeboxId: UUID, paused: Boolean) {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return&#10;        &#10;        if (paused &amp;&amp; playback.isPlaying) {&#10;            playback.audioPlayer.stopCurrentAudio()&#10;            playback.isPlaying = false&#10;            info(&quot;Paused jukebox: $jukeboxId&quot;)&#10;        } else if (!paused &amp;&amp; !playback.isPlaying) {&#10;            // Resume playback - would need to restart from current position&#10;            // This is complex with current implementation&#10;            info(&quot;Resuming jukebox: $jukeboxId (requires restart)&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calculates pitch multiplier based on RPM&#10;     */&#10;    private fun calculatePitchFromRpm(rpm: Float): Float {&#10;        if (rpm &lt;= 0) return 0f&#10;        &#10;        val pitchMultiplier = rpm / STANDARD_RPM&#10;        return pitchMultiplier.coerceIn(MIN_PITCH_CHANGE, MAX_PITCH_CHANGE)&#10;    }&#10;    &#10;    /**&#10;     * Gets the RPM that would produce a specific pitch&#10;     */&#10;    fun getRpmForPitch(pitch: Float): Float {&#10;        return pitch * STANDARD_RPM&#10;    }&#10;    &#10;    /**&#10;     * Gets current jukebox status&#10;     */&#10;    fun getJukeboxStatus(jukeboxId: UUID): JukeboxStatus? {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return null&#10;        val discData = AudioDiscRegistry.getDiscData(playback.discId) ?: return null&#10;        &#10;        return JukeboxStatus(&#10;            discData = discData,&#10;            rpm = playback.currentRpm,&#10;            pitch = calculatePitchFromRpm(playback.currentRpm),&#10;            isPlaying = playback.isPlaying,&#10;            position = playback.x to playback.y to playback.z&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Gets all active jukeboxes&#10;     */&#10;    fun getActiveJukeboxes(): Map&lt;UUID, JukeboxStatus&gt; {&#10;        return activeJukeboxes.mapNotNull { (id, playback) -&gt;&#10;            val discData = AudioDiscRegistry.getDiscData(playback.discId)&#10;            if (discData != null) {&#10;                id to JukeboxStatus(&#10;                    discData = discData,&#10;                    rpm = playback.currentRpm,&#10;                    pitch = calculatePitchFromRpm(playback.currentRpm),&#10;                    isPlaying = playback.isPlaying,&#10;                    position = Triple(playback.x, playback.y, playback.z)&#10;                )&#10;            } else null&#10;        }.toMap()&#10;    }&#10;    &#10;    /**&#10;     * Stops all jukeboxes&#10;     */&#10;    fun stopAllJukeboxes() {&#10;        val jukeboxIds = activeJukeboxes.keys.toList()&#10;        jukeboxIds.forEach { stopJukebox(it) }&#10;        info(&quot;Stopped all jukeboxes (${jukeboxIds.size})&quot;)&#10;    }&#10;    &#10;    data class JukeboxStatus(&#10;        val discData: AudioDiscRegistry.AudioDiscData,&#10;        val rpm: Float,&#10;        val pitch: Float,&#10;        val isPlaying: Boolean,&#10;        val position: Triple&lt;Double, Double, Double&gt;&#10;    )&#10;}&#10;&#10;/**&#10; * Utility functions for Create integration&#10; */&#10;object CreateAudioUtils {&#10;    &#10;    /**&#10;     * Converts Create rotation speed to RPM&#10;     * Create uses rotation units per tick, we convert to RPM&#10;     */&#10;    fun createSpeedToRpm(createSpeed: Float): Float {&#10;        // Create speed is in rotation units per tick&#10;        // 1 rotation = 360 degrees, 20 ticks per second, 60 seconds per minute&#10;        return abs(createSpeed) * 20f * 60f / 360f&#10;    }&#10;    &#10;    /**&#10;     * Gets descriptive text for RPM values&#10;     */&#10;    fun getRpmDescription(rpm: Float): String {&#10;        return when {&#10;            rpm &lt;= 0 -&gt; &quot;Stopped&quot;&#10;            rpm &lt; 16 -&gt; &quot;Very Slow (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 30 -&gt; &quot;Slow (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm in 30f..40f -&gt; &quot;Normal (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 60 -&gt; &quot;Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 100 -&gt; &quot;Very Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            else -&gt; &quot;Extremely Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gets color code for RPM display&#10;     */&#10;    fun getRpmColor(rpm: Float): String {&#10;        return when {&#10;            rpm &lt;= 0 -&gt; &quot;§7&quot; // Gray&#10;            rpm &lt; 20 -&gt; &quot;§c&quot; // Red (too slow)&#10;            rpm in 20f..50f -&gt; &quot;§a&quot; // Green (good)&#10;            rpm &lt; 80 -&gt; &quot;§e&quot; // Yellow (fast)&#10;            else -&gt; &quot;§c&quot; // Red (too fast)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>