<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AUDIO_SYSTEM.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AUDIO_SYSTEM.md" />
              <option name="updatedContent" value="# Audio Provider System&#10;&#10;This system provides automatic downloading and management of audio tools (ffmpeg and yt-dlp) for the CreateHarmonics mod.&#10;&#10;## Architecture&#10;&#10;### Core Components&#10;&#10;1. **AudioProvider Interface** (`audio/provider/AudioProvider.kt`)&#10;   - Defines the contract for all audio providers&#10;   - Methods: `isAvailable()`, `install()`, `getExecutablePath()`, `getName()`&#10;&#10;2. **AbstractDownloadableProvider** (`audio/provider/AbstractDownloadableProvider.kt`)&#10;   - Base implementation for downloadable audio tools&#10;   - Handles download, extraction, and executable discovery&#10;   - Platform-specific executable location&#10;   - Supports both direct downloads and zip archives&#10;&#10;3. **FFMPEG Provider** (`audio/provider/FFMPEG.kt`)&#10;   - Downloads ffmpeg based on OS and architecture&#10;   - Windows: gyan.dev builds&#10;   - macOS: evermeet.cx builds&#10;   - Linux: johnvansickle static builds&#10;&#10;4. **YTDL Provider** (`audio/provider/YTDL.kt`)&#10;   - Downloads yt-dlp from GitHub releases&#10;   - Platform-specific binaries for Windows, macOS, and Linux&#10;   - Supports ARM64 and x86_64 architectures&#10;&#10;5. **AudioProviderManager** (`audio/provider/AudioProviderManager.kt`)&#10;   - Central registry for all audio providers&#10;   - Manages provider installation and availability&#10;   - Provides status information&#10;&#10;6. **AudioDownloader** (`audio/AudioDownloader.kt`)&#10;   - High-level API for downloading and converting audio&#10;   - Uses yt-dlp for downloading from URLs&#10;   - Uses ffmpeg for audio conversion&#10;   - Automatically ensures providers are available&#10;&#10;## Usage&#10;&#10;### Basic Audio Download&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.AudioDownloader&#10;import java.io.File&#10;&#10;// Download and convert audio to OGG format&#10;val success = AudioDownloader.downloadAndConvert(&#10;    url = &quot;https://www.youtube.com/watch?v=example&quot;,&#10;    outputFile = File(&quot;audio/output.ogg&quot;),&#10;    format = &quot;ogg&quot;&#10;)&#10;&#10;if (success) {&#10;    println(&quot;Audio downloaded successfully!&quot;)&#10;}&#10;```&#10;&#10;### Check Provider Status&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.provider.AudioProviderManager&#10;&#10;// Check if all providers are ready&#10;val allReady = AudioProviderManager.areAllProvidersAvailable()&#10;&#10;// Get status for each provider&#10;val status = AudioProviderManager.getProviderStatus()&#10;status.forEach { (name, available) -&gt;&#10;    println(&quot;$name: ${if (available) &quot;Available&quot; else &quot;Not Available&quot;}&quot;)&#10;}&#10;```&#10;&#10;### Manual Provider Installation&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.audio.provider.FFMPEG&#10;import me.mochibit.createharmonics.audio.provider.YTDL&#10;&#10;// Install individual providers&#10;if (!FFMPEG.isAvailable()) {&#10;    FFMPEG.install()&#10;}&#10;&#10;if (!YTDL.isAvailable()) {&#10;    YTDL.install()&#10;}&#10;&#10;// Or install all missing providers&#10;AudioProviderManager.installMissingProviders()&#10;```&#10;&#10;### Creating Custom Music Discs&#10;&#10;```kotlin&#10;import me.mochibit.createharmonics.content.item.EtherealDiscItem&#10;import kotlin.time.Duration.Companion.minutes&#10;&#10;val customDisc = EtherealDiscItem(&#10;    comparatorOutput = 15,&#10;    soundEvent = { ModSounds.CUSTOM_DISC_SOUND.get() },&#10;    duration = 5.minutes&#10;)&#10;```&#10;&#10;## Directory Structure&#10;&#10;Audio providers are installed to:&#10;```&#10;audio_providers/&#10;├── ffmpeg/&#10;│   └── ffmpeg.exe (or ffmpeg on Unix)&#10;└── yt-dlp/&#10;    └── yt-dlp.exe (or yt-dlp on Unix)&#10;```&#10;&#10;## Supported Platforms&#10;&#10;- **Windows**: x86_64&#10;- **macOS**: x86_64 and ARM64 (Apple Silicon)&#10;- **Linux**: x86_64 and ARM64&#10;&#10;## Features&#10;&#10;- ✅ Automatic provider installation&#10;- ✅ Platform detection and appropriate binary selection&#10;- ✅ Recursive executable discovery in extracted archives&#10;- ✅ Executable permission management&#10;- ✅ Caching of executable paths&#10;- ✅ Error handling and logging&#10;- ✅ Support for multiple audio formats (ogg, mp3, wav, etc.)&#10;&#10;## Extension Points&#10;&#10;### Adding a New Provider&#10;&#10;1. Create a new object extending `AbstractDownloadableProvider`:&#10;&#10;```kotlin&#10;object NewProvider: AbstractDownloadableProvider(&#10;    &quot;provider-name&quot;,&#10;    File(&quot;audio_providers/provider-name&quot;),&#10;    &quot;download-file.zip&quot;,&#10;    &quot;provider-repo&quot;&#10;) {&#10;    override fun getDownloadUrl(): String {&#10;        val osName = System.getProperty(&quot;os.name&quot;).lowercase()&#10;        return when {&#10;            osName.contains(&quot;win&quot;) -&gt; &quot;https://example.com/windows-build.zip&quot;&#10;            osName.contains(&quot;mac&quot;) -&gt; &quot;https://example.com/macos-build.zip&quot;&#10;            osName.contains(&quot;linux&quot;) -&gt; &quot;https://example.com/linux-build.tar.gz&quot;&#10;            else -&gt; throw UnsupportedOperationException(&quot;Unsupported OS: $osName&quot;)&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;2. Register it in `AudioProviderManager`:&#10;&#10;```kotlin&#10;init {&#10;    registerProvider(FFMPEG)&#10;    registerProvider(YTDL)&#10;    registerProvider(NewProvider) // Add your provider&#10;}&#10;```&#10;&#10;## Notes&#10;&#10;- The system automatically handles zip extraction&#10;- Executables are made executable on Unix systems&#10;- Providers are only downloaded once (cached)&#10;- All operations are logged through the mod's logger&#10;- Thread-safe provider management&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DYNAMIC_PITCH_ARCHITECTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DYNAMIC_PITCH_ARCHITECTURE.md" />
              <option name="updatedContent" value="# Dynamic Pitch Shifting - Architecture Documentation&#10;&#10;This document explains the refactored audio processing system with dynamic pitch shifting support.&#10;&#10;## Architecture Overview&#10;&#10;The system now has better **separation of concerns** with the following components:&#10;&#10;### 1. **PitchFunction** (`PitchFunction.kt`)&#10;A functional interface that defines how pitch should vary over time.&#10;&#10;```kotlin&#10;fun interface PitchFunction {&#10;    fun getPitchAt(timeInSeconds: Double): Float&#10;}&#10;```&#10;&#10;**Built-in Factory Methods:**&#10;- `constant(pitch)` - Static pitch (original behavior)&#10;- `linear(start, end, duration)` - Linear interpolation between two pitches&#10;- `oscillate(base, amplitude, frequency)` - Vibrato/oscillating effect&#10;- `steps(pitches, stepDuration)` - Discrete pitch steps (robotic effect)&#10;- `custom(lambda)` - Custom function for any pitch pattern&#10;&#10;### 2. **PCMProcessor** (`PCMProcessor.kt`)&#10;Low-level audio sample processing operations. Separated for testability and clarity.&#10;&#10;**Responsibilities:**&#10;- Convert between byte arrays and 16-bit PCM samples&#10;- Apply constant pitch shifting (fast algorithm)&#10;- Apply dynamic pitch shifting (time-varying algorithm)&#10;- Resample audio between different sample rates&#10;&#10;**Key Methods:**&#10;- `ByteArray.toShortArray()` - Convert raw bytes to PCM samples&#10;- `ShortArray.toByteArray()` - Convert PCM samples back to bytes&#10;- `ShortArray.pitchShift(factor)` - Fast constant pitch shifting&#10;- `ShortArray.pitchShiftDynamic(pitchFunction, sampleRate)` - Dynamic pitch shifting&#10;&#10;### 3. **AudioEffectProcessor** (`AudioEffectProcessor.kt`)&#10;High-level audio effects processor that orchestrates PCM processing.&#10;&#10;**Responsibilities:**&#10;- Read PCM input streams&#10;- Apply pitch functions (constant or dynamic)&#10;- Write processed PCM output&#10;- Optimize by detecting constant pitch and using faster algorithm&#10;&#10;**Overloaded Methods:**&#10;```kotlin&#10;// Simple constant pitch&#10;processPCMStream(input, output, pitchShiftFactor: Float)&#10;&#10;// Dynamic pitch function&#10;processPCMStream(input, output, pitchFunction: PitchFunction)&#10;```&#10;&#10;### 4. **YoutubePlayer** (`YoutubePlayer.kt`)&#10;Manages the complete audio pipeline from YouTube URL to playable audio.&#10;&#10;**Pipeline:**&#10;1. Extract audio URL using yt-dlp (cached)&#10;2. Decode to raw PCM using FFmpeg&#10;3. Process PCM with pitch function&#10;4. Encode to OGG format using FFmpeg&#10;5. Stream chunks to Minecraft's audio system&#10;&#10;**Key Features:**&#10;- Supports both constant and dynamic pitch functions&#10;- Uses Kotlin Flow for efficient streaming&#10;- Registers streams in StreamRegistry for Minecraft integration&#10;&#10;### 5. **Supporting Components**&#10;&#10;- **AudioUrlCache** - Caches extracted YouTube URLs (1-hour TTL)&#10;- **StreamRegistry** - Maps ResourceLocations to audio streams&#10;- **BufferedYouTubeStream** - Pre-buffers audio data before playback&#10;&#10;## Usage Examples&#10;&#10;### Basic Usage (Constant Pitch)&#10;&#10;```kotlin&#10;// Lower pitch by 50%&#10;val pitchFunction = PitchFunction.constant(0.5f)&#10;&#10;YoutubePlayer.streamAudioWithPitchShift(&#10;    url = &quot;https://www.youtube.com/watch?v=...&quot;,&#10;    pitchFunction = pitchFunction,&#10;    sampleRate = 48000,&#10;    resourceLocation = myResourceLocation&#10;)&#10;```&#10;&#10;### Dynamic Pitch - Gradual Change&#10;&#10;```kotlin&#10;// Gradually increase pitch from 0.5x to 1.5x over 30 seconds&#10;val pitchFunction = PitchFunction.linear(&#10;    startPitch = 0.5f,&#10;    endPitch = 1.5f,&#10;    durationSeconds = 30.0&#10;)&#10;```&#10;&#10;### Dynamic Pitch - Vibrato Effect&#10;&#10;```kotlin&#10;// Add vibrato (slight pitch oscillation)&#10;val pitchFunction = PitchFunction.oscillate(&#10;    basePitch = 1.0f,      // Normal pitch&#10;    amplitude = 0.05f,     // ±5% variation&#10;    frequency = 5.0        // 5 Hz oscillation&#10;)&#10;```&#10;&#10;### Custom Pitch Function&#10;&#10;```kotlin&#10;// Custom swoosh effect using sine wave&#10;val pitchFunction = PitchFunction.custom { time -&gt;&#10;    1.0f + kotlin.math.sin(time * 2.0).toFloat() * 0.3f&#10;}&#10;```&#10;&#10;### Combining Effects&#10;&#10;```kotlin&#10;// Combine gradual shift with vibrato&#10;val baseShift = PitchFunction.linear(1.0f, 1.5f, 10.0)&#10;val vibrato = PitchFunction.oscillate(0.0f, 0.03f, 6.0)&#10;&#10;val combined = PitchFunction.custom { time -&gt;&#10;    baseShift.getPitchAt(time) + vibrato.getPitchAt(time)&#10;}&#10;```&#10;&#10;## How Dynamic Pitch Shifting Works&#10;&#10;1. **Input**: Original audio as PCM samples at a given sample rate&#10;2. **Time Mapping**: For each output sample position (in time), calculate:&#10;   - Current pitch factor from `pitchFunction.getPitchAt(time)`&#10;   - Corresponding input sample position&#10;3. **Interpolation**: Use linear interpolation between input samples&#10;4. **Output**: Write interpolated sample to output&#10;&#10;**Performance Optimization:**&#10;- If pitch is constant throughout (detected by sampling at start/mid/end), uses faster constant-pitch algorithm&#10;- If pitch is 1.0 everywhere, passes through without processing&#10;&#10;## Integration with Minecraft&#10;&#10;The system integrates with Minecraft's audio engine through:&#10;&#10;1. **ResourceLocation**: Each unique URL + pitch function combination gets a unique ID&#10;2. **StreamRegistry**: Minecraft's sound system looks up streams by ResourceLocation&#10;3. **SoundBufferLibraryMixin**: Intercepts sound loading to provide our custom streams&#10;4. **Flow-based Streaming**: Audio is processed and streamed in chunks for low latency&#10;&#10;## Files Changed/Added&#10;&#10;### New Files:&#10;- `PitchFunction.kt` - Pitch function interface and factory methods&#10;- `PCMProcessor.kt` - Low-level PCM processing utilities&#10;- `PitchFunctionExamples.kt` - Usage examples and presets&#10;&#10;### Modified Files:&#10;- `AudioEffectProcessor.kt` - Refactored to use PitchFunction&#10;- `YoutubePlayer.kt` - Updated to support dynamic pitch functions&#10;- `EtherealDiscItem.kt` - Example usage with pitch functions&#10;&#10;## Benefits of This Architecture&#10;&#10;1. **Separation of Concerns**: Each component has a single, clear responsibility&#10;2. **Testability**: PCM processing is isolated and can be tested independently&#10;3. **Extensibility**: Easy to add new pitch functions without touching core processing&#10;4. **Type Safety**: Compile-time checking of pitch function signatures&#10;5. **Performance**: Automatic optimization for constant pitch&#10;6. **Flexibility**: Supports any time-varying pitch pattern&#10;&#10;## Future Enhancements&#10;&#10;Potential improvements:&#10;- Add more built-in pitch functions (exponential, logarithmic, etc.)&#10;- Support for other effects (reverb, echo, filters)&#10;- Real-time pitch adjustment during playback&#10;- Pitch function presets library&#10;- Multi-track audio support&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/PITCH_SHIFT_USAGE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/PITCH_SHIFT_USAGE.md" />
              <option name="updatedContent" value="# Audio Pitch Shifting Integration&#10;&#10;## Overview&#10;The system now includes pitch shifting capabilities using TarsosDSP. Audio is streamed through FFmpeg and processed in real-time with pitch effects.&#10;&#10;## Usage&#10;&#10;### Basic Usage (No Effects)&#10;```kotlin&#10;// Stream audio without effects&#10;val audioStream = YoutubePlayer.streamAudio(&#10;    url = &quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;,&#10;    format = &quot;ogg&quot;,&#10;    sampleRate = 48000,&#10;    channels = 2&#10;)&#10;// Use the stream as needed&#10;```&#10;&#10;### Pitch Shifting&#10;```kotlin&#10;// Stream audio with pitch shift&#10;val audioStream = YoutubePlayer.streamAudioWithPitchShift(&#10;    url = &quot;https://www.youtube.com/watch?v=dQw4w9WgXcQ&quot;,&#10;    pitchShiftFactor = 1.5f,  // 1.5 = higher pitch, 0.5 = lower pitch&#10;    sampleRate = 48000,&#10;    channels = 2&#10;)&#10;// Use the stream as needed&#10;```&#10;&#10;## Optimizing Startup Time&#10;&#10;### 1. Pre-initialize providers&#10;To avoid delays on first stream, initialize providers early:&#10;&#10;```kotlin&#10;// During mod initialization&#10;runBlocking {&#10;    YoutubePlayer.initializeProviders()&#10;}&#10;```&#10;&#10;### 2. Pre-warm the cache&#10;For known URLs, pre-extract the direct stream URL:&#10;&#10;```kotlin&#10;// Pre-warm cache for a URL (non-blocking)&#10;YoutubePlayer.prewarmCache(&quot;https://www.youtube.com/watch?v=...&quot;)&#10;```&#10;&#10;### 3. Initialize on startup&#10;In your mod's initialization:&#10;&#10;```kotlin&#10;@Mod.EventBusSubscriber(modid = &quot;yourmod&quot;, bus = Mod.EventBusSubscriber.Bus.MOD)&#10;object ModSetup {&#10;    @SubscribeEvent&#10;    fun onCommonSetup(event: FMLCommonSetupEvent) {&#10;        event.enqueueWork {&#10;            // Initialize providers in background&#10;            GlobalScope.launch {&#10;                YoutubePlayer.initializeProviders()&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;## Performance Notes&#10;&#10;### Current Implementation&#10;- **First stream**: 2-5 seconds (downloads ffmpeg/yt-dlp if needed)&#10;- **Subsequent streams (same URL)**: Near-instant (uses cached URL)&#10;- **Subsequent streams (different URL)**: 1-2 seconds (only yt-dlp extraction)&#10;&#10;### Optimizations Applied&#10;1. ✅ Lazy provider installation (only downloads once)&#10;2. ✅ URL caching (5-minute TTL, avoids repeated yt-dlp calls)&#10;3. ✅ Pre-warming capability (extract URLs before streaming)&#10;4. ✅ Asynchronous processing (returns stream immediately)&#10;5. ✅ Buffer optimization (64KB pipes for smooth streaming)&#10;&#10;## Architecture&#10;&#10;```&#10;YouTube URL&#10;    ↓&#10;[Cache Check] → Cache Hit → [Direct URL]&#10;    ↓ Cache Miss&#10;[yt-dlp] → Extract URL → [Cache Store]&#10;    ↓&#10;[FFmpeg] → Decode to WAV&#10;    ↓&#10;[TarsosDSP] → Pitch Shift (optional)&#10;    ↓&#10;[Output Stream] → Consumer&#10;```&#10;&#10;## Dependency Setup&#10;&#10;The TarsosDSP library has been added to `build.gradle`:&#10;- Repository: JitPack (`https://jitpack.io`)&#10;- Dependency: `com.github.JorenSix:TarsosDSP:v2.5`&#10;&#10;If you encounter build issues, you may need to:&#10;1. Sync Gradle dependencies in your IDE&#10;2. Run `gradlew --refresh-dependencies`&#10;3. Ensure Java 17 is being used&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/CreateJukeboxAudioPlayer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/CreateJukeboxAudioPlayer.kt" />
              <option name="updatedContent" value="package me.mochibit.createharmonics.audio&#10;&#10;import me.mochibit.createharmonics.Logger.err&#10;import me.mochibit.createharmonics.Logger.info&#10;import net.minecraft.client.Minecraft&#10;import net.minecraft.sounds.SoundSource&#10;import java.util.*&#10;import kotlin.math.*&#10;&#10;/**&#10; * RPM-based audio player for Create-style jukeboxes&#10; * Handles pitch changes based on rotational speed&#10; */&#10;class CreateJukeboxAudioPlayer {&#10;    &#10;    companion object {&#10;        private val activeJukeboxes = mutableMapOf&lt;UUID, JukeboxPlayback&gt;()&#10;        private const val STANDARD_RPM = 33.33f // Standard vinyl RPM for 1.0 pitch&#10;        private const val MAX_PITCH_CHANGE = 4.0f // Maximum pitch multiplier&#10;        private const val MIN_PITCH_CHANGE = 0.25f // Minimum pitch multiplier&#10;    }&#10;    &#10;    data class JukeboxPlayback(&#10;        val discId: UUID,&#10;        val audioPlayer: SimpleYouTubeAudioPlayer,&#10;        var currentRpm: Float,&#10;        var isPlaying: Boolean,&#10;        val x: Double,&#10;        val y: Double,&#10;        val z: Double&#10;    )&#10;    &#10;    /**&#10;     * Starts playing a disc in a jukebox at given RPM&#10;     */&#10;    fun playDisc(&#10;        jukeboxId: UUID,&#10;        discId: UUID,&#10;        rpm: Float,&#10;        x: Double,&#10;        y: Double,&#10;        z: Double,&#10;        volume: Float = 1.0f&#10;    ): Boolean {&#10;        try {&#10;            // Stop any existing playback for this jukebox&#10;            stopJukebox(jukeboxId)&#10;            &#10;            // Get disc data&#10;            val discData = AudioDiscRegistry.getDiscData(discId) ?: run {&#10;                err(&quot;Disc not found: $discId&quot;)&#10;                return false&#10;            }&#10;            &#10;            info(&quot;Starting jukebox playback: ${discData.title} at ${rpm} RPM&quot;)&#10;            &#10;            // Calculate pitch based on RPM&#10;            val pitch = calculatePitchFromRpm(rpm)&#10;            &#10;            // Create new audio player for this jukebox&#10;            val audioPlayer = SimpleYouTubeAudioPlayer()&#10;            &#10;            // Start playback&#10;            val playbackFuture = audioPlayer.playYouTubeAudioDirect(&#10;                discData.youtubeUrl, &#10;                volume&#10;            )&#10;            &#10;            // Store jukebox state&#10;            val playback = JukeboxPlayback(&#10;                discId = discId,&#10;                audioPlayer = audioPlayer,&#10;                currentRpm = rpm,&#10;                isPlaying = true,&#10;                x = x,&#10;                y = y,&#10;                z = z&#10;            )&#10;            &#10;            activeJukeboxes[jukeboxId] = playback&#10;            &#10;            // Handle playback result&#10;            playbackFuture.thenAccept { success -&gt;&#10;                if (!success) {&#10;                    err(&quot;Failed to start audio playback for jukebox: $jukeboxId&quot;)&#10;                    activeJukeboxes.remove(jukeboxId)&#10;                } else {&#10;                    info(&quot;Successfully started jukebox audio at pitch: $pitch&quot;)&#10;                }&#10;            }&#10;            &#10;            return true&#10;            &#10;        } catch (e: Exception) {&#10;            err(&quot;Error playing disc in jukebox: ${e.message}&quot;)&#10;            return false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Updates RPM for a playing jukebox (changes pitch in real-time)&#10;     */&#10;    fun updateRpm(jukeboxId: UUID, newRpm: Float) {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return&#10;        &#10;        if (!playback.isPlaying) return&#10;        &#10;        val oldPitch = calculatePitchFromRpm(playback.currentRpm)&#10;        val newPitch = calculatePitchFromRpm(newRpm)&#10;        &#10;        playback.currentRpm = newRpm&#10;        &#10;        info(&quot;Updated jukebox RPM: ${playback.currentRpm} -&gt; $newRpm (pitch: $oldPitch -&gt; $newPitch)&quot;)&#10;        &#10;        // For real-time pitch changes, we'd need to restart with new pitch&#10;        // Java's audio system doesn't support real-time pitch shifting easily&#10;        // This is a limitation we'll note for future enhancement&#10;        &#10;        // TODO: Implement real-time pitch shifting or restart playback with new pitch&#10;        // For now, we just update the stored RPM value&#10;    }&#10;    &#10;    /**&#10;     * Stops a jukebox playback&#10;     */&#10;    fun stopJukebox(jukeboxId: UUID) {&#10;        val playback = activeJukeboxes.remove(jukeboxId) ?: return&#10;        &#10;        playback.audioPlayer.stopCurrentAudio()&#10;        playback.isPlaying = false&#10;        &#10;        info(&quot;Stopped jukebox: $jukeboxId&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Pauses/resumes jukebox (when RPM drops to 0)&#10;     */&#10;    fun setJukeboxPaused(jukeboxId: UUID, paused: Boolean) {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return&#10;        &#10;        if (paused &amp;&amp; playback.isPlaying) {&#10;            playback.audioPlayer.stopCurrentAudio()&#10;            playback.isPlaying = false&#10;            info(&quot;Paused jukebox: $jukeboxId&quot;)&#10;        } else if (!paused &amp;&amp; !playback.isPlaying) {&#10;            // Resume playback - would need to restart from current position&#10;            // This is complex with current implementation&#10;            info(&quot;Resuming jukebox: $jukeboxId (requires restart)&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calculates pitch multiplier based on RPM&#10;     */&#10;    private fun calculatePitchFromRpm(rpm: Float): Float {&#10;        if (rpm &lt;= 0) return 0f&#10;        &#10;        val pitchMultiplier = rpm / STANDARD_RPM&#10;        return pitchMultiplier.coerceIn(MIN_PITCH_CHANGE, MAX_PITCH_CHANGE)&#10;    }&#10;    &#10;    /**&#10;     * Gets the RPM that would produce a specific pitch&#10;     */&#10;    fun getRpmForPitch(pitch: Float): Float {&#10;        return pitch * STANDARD_RPM&#10;    }&#10;    &#10;    /**&#10;     * Gets current jukebox status&#10;     */&#10;    fun getJukeboxStatus(jukeboxId: UUID): JukeboxStatus? {&#10;        val playback = activeJukeboxes[jukeboxId] ?: return null&#10;        val discData = AudioDiscRegistry.getDiscData(playback.discId) ?: return null&#10;        &#10;        return JukeboxStatus(&#10;            discData = discData,&#10;            rpm = playback.currentRpm,&#10;            pitch = calculatePitchFromRpm(playback.currentRpm),&#10;            isPlaying = playback.isPlaying,&#10;            position = playback.x to playback.y to playback.z&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Gets all active jukeboxes&#10;     */&#10;    fun getActiveJukeboxes(): Map&lt;UUID, JukeboxStatus&gt; {&#10;        return activeJukeboxes.mapNotNull { (id, playback) -&gt;&#10;            val discData = AudioDiscRegistry.getDiscData(playback.discId)&#10;            if (discData != null) {&#10;                id to JukeboxStatus(&#10;                    discData = discData,&#10;                    rpm = playback.currentRpm,&#10;                    pitch = calculatePitchFromRpm(playback.currentRpm),&#10;                    isPlaying = playback.isPlaying,&#10;                    position = Triple(playback.x, playback.y, playback.z)&#10;                )&#10;            } else null&#10;        }.toMap()&#10;    }&#10;    &#10;    /**&#10;     * Stops all jukeboxes&#10;     */&#10;    fun stopAllJukeboxes() {&#10;        val jukeboxIds = activeJukeboxes.keys.toList()&#10;        jukeboxIds.forEach { stopJukebox(it) }&#10;        info(&quot;Stopped all jukeboxes (${jukeboxIds.size})&quot;)&#10;    }&#10;    &#10;    data class JukeboxStatus(&#10;        val discData: AudioDiscRegistry.AudioDiscData,&#10;        val rpm: Float,&#10;        val pitch: Float,&#10;        val isPlaying: Boolean,&#10;        val position: Triple&lt;Double, Double, Double&gt;&#10;    )&#10;}&#10;&#10;/**&#10; * Utility functions for Create integration&#10; */&#10;object CreateAudioUtils {&#10;    &#10;    /**&#10;     * Converts Create rotation speed to RPM&#10;     * Create uses rotation units per tick, we convert to RPM&#10;     */&#10;    fun createSpeedToRpm(createSpeed: Float): Float {&#10;        // Create speed is in rotation units per tick&#10;        // 1 rotation = 360 degrees, 20 ticks per second, 60 seconds per minute&#10;        return abs(createSpeed) * 20f * 60f / 360f&#10;    }&#10;    &#10;    /**&#10;     * Gets descriptive text for RPM values&#10;     */&#10;    fun getRpmDescription(rpm: Float): String {&#10;        return when {&#10;            rpm &lt;= 0 -&gt; &quot;Stopped&quot;&#10;            rpm &lt; 16 -&gt; &quot;Very Slow (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 30 -&gt; &quot;Slow (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm in 30f..40f -&gt; &quot;Normal (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 60 -&gt; &quot;Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            rpm &lt; 100 -&gt; &quot;Very Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;            else -&gt; &quot;Extremely Fast (${String.format(&quot;%.1f&quot;, rpm)} RPM)&quot;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gets color code for RPM display&#10;     */&#10;    fun getRpmColor(rpm: Float): String {&#10;        return when {&#10;            rpm &lt;= 0 -&gt; &quot;§7&quot; // Gray&#10;            rpm &lt; 20 -&gt; &quot;§c&quot; // Red (too slow)&#10;            rpm in 20f..50f -&gt; &quot;§a&quot; // Green (good)&#10;            rpm &lt; 80 -&gt; &quot;§e&quot; // Yellow (fast)&#10;            else -&gt; &quot;§c&quot; // Red (too fast)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/effect/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/me/mochibit/createharmonics/audio/effect/README.md" />
              <option name="updatedContent" value="# Audio Effect Chain System - Refactoring Documentation&#10;&#10;## Overview&#10;&#10;The audio system has been refactored to support a clean, modular effect chain architecture. Instead of hardcoding effects directly in the audio stream processing, you can now define and chain multiple effects together.&#10;&#10;## Key Changes&#10;&#10;### Before (Old System)&#10;```kotlin&#10;// Pitch shifting was hardcoded in BufferedAudioStream&#10;val stream = BufferedAudioStream(audioSource, pitchFunction, sampleRate, ...)&#10;```&#10;&#10;### After (New System)&#10;```kotlin&#10;// Effects are modular and chainable&#10;val effectChain = EffectChain(&#10;    PitchShiftEffect(pitchFunction),&#10;    ReverbEffect(roomSize = 0.5f, wetMix = 0.3f)&#10;)&#10;val stream = BufferedAudioStream(audioSource, effectChain, sampleRate, ...)&#10;```&#10;&#10;## Architecture&#10;&#10;### Core Components&#10;&#10;1. **AudioEffect** - Base interface for all effects&#10;   - `process(samples, timeInSeconds, sampleRate)` - Process audio samples&#10;   - `reset()` - Reset internal state&#10;   - `getName()` - Get effect name for debugging&#10;&#10;2. **EffectChain** - Manages multiple effects in sequence&#10;   - Effects are applied in order&#10;   - Can be built dynamically with `append()`&#10;   - Implements `AudioEffect` itself (composite pattern)&#10;&#10;3. **BufferedAudioStream** - Refactored to use effect chains&#10;   - Reads raw PCM data normally (no processing during read)&#10;   - Applies effect chain on-demand during playback&#10;   - Clean separation of concerns&#10;&#10;4. **AudioStreamProcessor** - Simplified to stream raw PCM&#10;   - No longer processes effects&#10;   - Just decodes and streams raw audio data&#10;&#10;### Available Effects&#10;&#10;#### 1. PitchShiftEffect&#10;Changes the pitch/speed of audio using time-domain resampling.&#10;&#10;```kotlin&#10;PitchShiftEffect(&#10;    pitchFunction = PitchFunction.constant(1.5f), // 50% faster&#10;    minPitch = 0.5f,&#10;    maxPitch = 2.0f&#10;)&#10;```&#10;&#10;#### 2. ReverbEffect&#10;Adds room ambience/echo using a feedback delay network.&#10;&#10;```kotlin&#10;ReverbEffect(&#10;    roomSize = 0.5f,  // 0.0 to 1.0 - size of the room&#10;    damping = 0.5f,   // 0.0 to 1.0 - high frequency damping&#10;    wetMix = 0.3f     // 0.0 to 1.0 - amount of reverb&#10;)&#10;```&#10;&#10;#### 3. VolumeEffect&#10;Controls volume/gain with optional fade effects.&#10;&#10;```kotlin&#10;VolumeEffect(0.8f)  // 80% volume&#10;&#10;// Or with fade&#10;VolumeEffect.fadeIn(durationSeconds = 3.0)&#10;VolumeEffect.fadeOut(startTime = 10.0, durationSeconds = 2.0)&#10;```&#10;&#10;#### 4. LowPassFilterEffect&#10;Removes high frequencies, creating a muffled/underwater sound.&#10;&#10;```kotlin&#10;LowPassFilterEffect(&#10;    cutoffFrequency = 1000f,  // Hz&#10;    resonance = 0.7f           // 0.0 to 1.0&#10;)&#10;```&#10;&#10;## Usage Examples&#10;&#10;### Example 1: Simple Pitch Shift (Backward Compatible)&#10;```kotlin&#10;val pitchFunction = PitchFunction.constant(1.5f)&#10;AudioPlayer.fromYoutube(url, pitchFunction, resourceLocation = resourceLocation)&#10;```&#10;&#10;### Example 2: Pitch + Reverb&#10;```kotlin&#10;val effectChain = EffectChain(&#10;    PitchShiftEffect(PitchFunction.constant(0.8f)),&#10;    ReverbEffect(roomSize = 0.7f, wetMix = 0.4f)&#10;)&#10;AudioPlayer.fromYoutube(url, effectChain, resourceLocation = resourceLocation)&#10;```&#10;&#10;### Example 3: Complex Chain&#10;```kotlin&#10;val effectChain = EffectChain(&#10;    PitchShiftEffect(PitchFunction.constant(1.2f)),&#10;    VolumeEffect(0.8f),&#10;    LowPassFilterEffect(cutoffFrequency = 3000f),&#10;    ReverbEffect(roomSize = 0.6f, wetMix = 0.2f)&#10;)&#10;AudioPlayer.streamAudio(audioSource, effectChain, resourceLocation = resourceLocation)&#10;```&#10;&#10;### Example 4: Dynamic Chain Building&#10;```kotlin&#10;var chain = EffectChain(PitchShiftEffect(PitchFunction.constant(1.0f)))&#10;&#10;if (enableReverb) {&#10;    chain = chain.append(ReverbEffect(roomSize = 0.5f, wetMix = 0.3f))&#10;}&#10;&#10;chain = chain.append(VolumeEffect(0.9f))&#10;AudioPlayer.fromYoutube(url, chain, resourceLocation = resourceLocation)&#10;```&#10;&#10;### Example 5: No Effects&#10;```kotlin&#10;// Empty chain - audio plays normally&#10;AudioPlayer.fromYoutube(url, EffectChain.empty(), resourceLocation = resourceLocation)&#10;&#10;// Or use default parameter&#10;AudioPlayer.streamAudio(audioSource, resourceLocation = resourceLocation)&#10;```&#10;&#10;## Benefits of the Refactored System&#10;&#10;1. **Modularity** - Each effect is a separate, testable component&#10;2. **Composability** - Easily chain multiple effects together&#10;3. **Extensibility** - Add new effects without modifying core code&#10;4. **Clean Code** - Separation of concerns between streaming and processing&#10;5. **Backward Compatibility** - Old PitchFunction API still works&#10;6. **Performance** - Effects applied on-demand, not during streaming&#10;&#10;## Creating Custom Effects&#10;&#10;To create a custom effect, implement the `AudioEffect` interface:&#10;&#10;```kotlin&#10;class MyCustomEffect : AudioEffect {&#10;    override fun process(samples: ShortArray, timeInSeconds: Double, sampleRate: Int): ShortArray {&#10;        // Your processing logic here&#10;        return processedSamples&#10;    }&#10;    &#10;    override fun reset() {&#10;        // Reset any internal state (buffers, etc.)&#10;    }&#10;    &#10;    override fun getName(): String = &quot;MyCustomEffect&quot;&#10;}&#10;```&#10;&#10;Then use it in a chain:&#10;&#10;```kotlin&#10;val chain = EffectChain(&#10;    PitchShiftEffect(PitchFunction.constant(1.0f)),&#10;    MyCustomEffect(),&#10;    ReverbEffect()&#10;)&#10;```&#10;&#10;## Technical Details&#10;&#10;### Processing Flow&#10;&#10;1. **FFmpeg** decodes audio to raw PCM (16-bit mono, 48kHz)&#10;2. **AudioStreamProcessor** streams raw PCM data to BufferedAudioStream&#10;3. **BufferedAudioStream** queues raw samples in a ring buffer&#10;4. When Minecraft reads audio data:&#10;   - Raw samples are extracted from the queue&#10;   - **EffectChain** processes the samples through each effect&#10;   - Processed samples are returned to Minecraft's audio system&#10;5. **PcmAudioStream** (Java wrapper) passes data to Minecraft&#10;&#10;### Effect Order Matters&#10;&#10;Effects are applied in the order they're added to the chain:&#10;&#10;```kotlin&#10;// This applies pitch first, then reverb&#10;EffectChain(&#10;    PitchShiftEffect(...),&#10;    ReverbEffect(...)&#10;)&#10;&#10;// This applies reverb first, then pitch (different sound!)&#10;EffectChain(&#10;    ReverbEffect(...),&#10;    PitchShiftEffect(...)&#10;)&#10;```&#10;&#10;### Performance Considerations&#10;&#10;- Effects are applied on-demand during playback (real-time)&#10;- Processing happens in chunks (default: 1 second of audio)&#10;- For optimal performance, keep effect chains short&#10;- Complex effects (like reverb) have more overhead than simple effects (like volume)&#10;&#10;## Migration Guide&#10;&#10;If you have existing code using the old API:&#10;&#10;```kotlin&#10;// OLD&#10;val stream = BufferedAudioStream(audioSource, pitchFunction, ...)&#10;&#10;// NEW (backward compatible)&#10;val stream = BufferedAudioStream(audioSource, &#10;    EffectChain(PitchShiftEffect(pitchFunction)), &#10;    ...)&#10;&#10;// Or use the helper method&#10;AudioPlayer.streamAudio(audioSource, pitchFunction, ...)&#10;```&#10;&#10;The `AudioPlayer` has overloaded methods that accept both `PitchFunction` and `EffectChain`, ensuring complete backward compatibility.&#10;&#10;## See Also&#10;&#10;- `EffectChainExamples.kt` - More usage examples&#10;- `AudioEffect.kt` - Base interface documentation&#10;- `EffectChain.kt` - Chain management&#10;- Individual effect files for implementation details&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/assets/createharmonics/textures/gui/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/assets/createharmonics/textures/gui/README.md" />
              <option name="updatedContent" value="# Andesite Jukebox GUI Texture&#10;&#10;This file should be a PNG image with the following specifications:&#10;- Filename: andesite_jukebox.png&#10;- Size: 256x256 pixels (texture atlas size)&#10;- Image content: A standard Minecraft GUI background (176x166 pixels)&#10;  - Main container: 176x166 pixels&#10;  - Single item slot at coordinates (80, 35) - centered horizontally&#10;  - Player inventory slots below (standard layout)&#10;  - Hotbar slots at the bottom (standard layout)&#10;&#10;The GUI should have:&#10;- A gray background similar to other Minecraft GUIs&#10;- One centered slot for the Ethereal Disc (18x18 pixels)&#10;- Standard player inventory rendering below (9x3 slots)&#10;- Standard hotbar rendering at bottom (9x1 slots)&#10;&#10;You can use any Minecraft GUI texture as a template (like chest.png or furnace.png)&#10;and modify it to have a single centered slot instead of multiple slots.&#10;&#10;For now, you can use the default Minecraft inventory texture, or copy another GUI texture&#10;from Minecraft or Create mod as a base.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>